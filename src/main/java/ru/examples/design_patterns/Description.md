- S - Single Responsibility Principle (Принцип единственной ответственности);
- O - Open-Closed Principle (Принцип открытости-закрытости);
- L - Liskov Substitution Principle (Принцип подстановки Барбары Лисков);
- I - Interface Segregation Principle (Принцип разделения интерфейса);
- D - Dependency Inversion Principle (Принцип инверсии зависимостей);

S - Каждый класс должен решать лишь одну задачу.
    Класс должен быть ответственен лишь за что-то одно. Если класс отвечает за решение нескольких задач,
    его подсистемы, реализующие решение этих задач, оказываются связанными друг с другом.
    Изменения в одной такой подсистеме ведут к изменениям в другой.

O - Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации.

L - Принцип подстановки Барбары Лисков
    Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов.
    Цель этого принципа заключаются в том, чтобы классы-наследники могли бы использоваться вместо родительских классов,
    от которых они образованы, не нарушая работу программы. Если оказывается, что в коде проверяется тип класса,
    значит принцип подстановки нарушается.

I - Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента.
    Клиенты не должны зависеть от интерфейсов, которые они не используют.
    Этот принцип направлен на устранение недостатков, связанных с реализацией больших интерфейсов.


D - Принцип инверсии зависимостей
    Объектом зависимости должна быть абстракция, а не что-то конкретное.
    Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
    Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Принципы проектирования:
1) Выделите аспекты приложения, которые могут изменяться, и отделите их от тех, которые всегда остаются постоянными
2) Программируйте на уровне интерфейса, а не на уровне реализации
3) Отдавайте предпочтение композиции перед наследованием
4) Стремитесь к слабой связанности взаимодействующих объектов
5) Классы должны быть открыты для расширения, но закрыты для изменения.
6) Код должен зависеть от абстракций, а не от конкретных классов

ООП- парадигма програмирования, в которой ключевым блоком является объект, который соотносится с объектов в конкретной задаче.

Главные аспекты:
- Любая система состоит из объектов
- Каждый объект имеет состояние и поведение
- Объекты взаимодействуют между собой

Принципы ООП:
- Инкапсуляция;
- Полиморфизм;
- Наследование;

Инкапсуляция:
- механизм, благодаря которому любой класс или часть системы рассматривается как отдельный модуль и ользователь этого 
модуля может взаимодействовать с ним только определёнными способами и не видит реализации этого модуля
- сводит к минимуму кол-во связей между частями системы, тем самым, упрощая изменение модулей (рефакторинг)

Наследование:
- механизм создания одного класса с помощью другого с использованием всех свойств и методов суеркласса добавляя новые 
свойства и методы при необходимости;
- отображает иерархичность окружающего мира;

Полиморфизм:
- механизм, благодаря которому подклассы могут изменять реализацию методов суперкласса, сохраняя его сигнатуру, 
благодяря чему интерфейс суперкласса остаётся неизменным
- позволяет работать с объектами подклассов как с объектами суперкласса, даже с учётом того, что реализация определённых 
методов у подклассов может отличаться от реализации методов суперкласса


Шаблон проектирования - это именованное эффективное решение характерной задачи проектирования программного обеспечения.
UML - Unified Modeling Language

Паттерн — решение задачи в контексте.
Контекстом называется ситуация, в которой применяется паттерн. Ситуация должна быть достаточно типичной и распространенной.
Задачей называется цель, которой вы хотите добиться в контексте, в совокупности со всеми ограничениями, присущими контексту.
Решением называется обобщенная архитектура, которая достигает заданной цели при соблюдении набора ограничений.


Классификация паттернов проектирования в зависимости от цели

Порождающие (связаны с созданием экземпляров объектов; все они обеспечивают средства логической изоляции клиента от создаваемых объектов):
1) Абстрактная фабрика
2) Фабричный метод
3) Одиночка
4) Строитель
5) Прототип

Поведенческие (Паттерны, принадлежащие к поведенческой категории, относятся к взаимодействиям и распределению обязанностей между классами и объектами):
1) Посетитель
2) Посредник
3) Шаблонный метод
4) Итератор
5) Команда
6) Хранитель
7) Наблюдатель
8) Интерпретатор
9) Цепочка обязанностей
10) Состояние
11) Стратегия

Структурные (объединяют классы или объекты в более крупные структуры):
1) Декоратор
2) Компоновщик
3) Заместитель
4) Фасад
5) Приспособленец
6) Мост
7) Адаптер

Классификация паттернов в отношении к объектам или классам
Паттерны классов(описывают определение отношений между классами посредством наследования. Отношения в паттернах классов определяются на стадии компиляции):
1) Шаблонный метод
2) Адаптер
3) Фабричный метод
4) Интерпретатор

Паттерны объектов (описывают отношения между объектами, прежде всего относящиеся к композиции. Отношения в паттернах 
объектов обычно определяются на стадии выполнения, а следовательно, обладают большей динамичностью и гибкостью):
1) Компоновщик
2) Декоратор
3) Заместитель
4) Стратегия
5) Мост
6) Приспособленец
7) Абстрактаня фабрика
8) Одиночка
9) Посетитель
10) Итератор
11) Фасад
12) Команда
13) Хранитель
14) Наблюдетель
15) Цепочка Обязанностей
16) Посредник
17) Прототип
18) Состояние
19) Строитель

Фабричный метод (factory method) - создание интерфейса, который создаёт объект. При этом, выбор того, экземпляр какого 
класса создавать остаётся за классами, которые имплементируют данный интерфейс.

Используется для делегирования создания экземпляров, другому классу;

Примеры использования:
1) заранее неизвестно, экземпляры, какого класса нужно будет создавать;
2) класс спроектирован таким образом, что создаваемые им объекты имеют свойства определённого класса.

Абстрактная фабрика (abstract factory) - создание интерфейса, для создания множества взаимосвязанных или взаимозависимых 
объектов, без жёсткой привязки к конкретным классам. 

Используется для создания множеств взаимосвязанных объектов

Примеры использования:
1) Система не должна зависить от метода создания, компоновки и представления входящих в неё объектов
2) Входящие взаимосвязанные объекты должны использоваться вместе
3) Система должна конфигурироваться одним из множеств объектов, из которых она состоит
4) Нам необходимо предоставить множество объектов, раскрывая только их интерфейсы но не реализацию

Одиночка (singleton) - гарантировать, что у класса будет только один единственный экземпляр и к нему будет предоставлена 
глобальная точка доступа

Используется для создания единственного экземпляра определённого класса

Примеры использования:
1) Необходим только один экземпляр конкретного класса, который доступен для всех клиентов
2) единственный экземпляр должен наследоваться путём порождения подклассов, при этом, клиенты имеют возможность работать
с классом наследником без модификации своего кода.

Строитель (builder) - отделить конструирование сложного объекта от его представления таким образом, чтобы в результате
одного и того же конструирования мы могли получить разные представления.

Используется для создания различных объектов из одного набора данных

Примеры использования:
1) Порядок создания сложного объекта не должен зависеть от того, из каких частей этот объект состоит и того, как эти 
объекты взаимосвязаны
2) Процесс конструирования объекта должен представлять различные представления объекта, который мы конструируем


Прототип (prototype) - определяет вид создаваемых объектов с помощью экземпляра - прототипа и создаёт новые объекты, 
копируя этот прототип

Используется для создания копий заданного объекта

Примеры использования:
1) Классы, экземпляры которых необходимо создать определяются во время выполнения программы
2) Для избежания построения иерархии классов, фабрик или параллельных иерархий классов
3) Экземплярв класса могут находится в одном из немногих возможных состояний

Адаптер (adapter) - преобразование интерфейса одного класса в интерфейс того класса, который необходим клиенту

Используется для обеспечения совместной работы классов, интерфейсы которых несовместимы

Примеры использования:
1) Интерфейс класса, который мы хотим использовать не соответствует нашим потребностям;
2) Необходим класс, который должен взаимодействовать с классами, которые ему неизвестны или не связаны с ним
3) Необходимо использовать несколько существующих подклассов, но нецелесообразно использовать методы этих классов создавая их новые подклассы


Мост (bridge) - отделить абстракцию от её реализации таким образом, чтобы мы могли изменять независимо друг от друга и то и другое

Используется для получения преимуществ наследования без потери гибкости

Примеры использования:
1) Предотвращение жесткой привязки абстракции от реализации (например, реализацию необходимо выбрать во время выполнения программы)
2) В будущем мы хотим расширять с помощью подклассов и реализацию и абстракцию
3) Если изменения в реализации не должны отображатся на клиентах абстракции
4) Для разделения одной реализации между несколькими объектами и не показывать это клиенту

Компоновщик (composite) - скомпонировать объекты в структуры по типу "дерева", позволяя клиентам единообразно трактовать 
отдельные и составные объекты 

Используется для группировки мелких компонентов в более крупные , которые , в свою очередь, могут стать основой для ещё 
более крпных структур

Примеры использования:
1) Для представлении иерархии часть-целое
2) Мы хотим, чтобы клиенты одним способом трактовали как отдельные, так и составные объекты

Декоратор (decorator) - динамическое добавление новых обязанностей объекту

Используется в качестве альтернвтивы пораждению подклассов для расширения функциональности

Примеры использования:
1) Динамическое и понятное клиентам добавления обязанностей объектам
2) реализация обязанностей, которые могут быть сняты с объекта 
3) Расширение класса путём порождения подклассов невозможно по каким-либо причинам


Фасад (facade) - пердоставить унифицированный интерфейс вместо нескольких интерфейсов подсистемы

Используется для определения  нтерфейса высокого уровня, который упрощает использование подсистемы

Примеры использования:
1) изолирование клиентов от компонентов подсистемы, упрощая работу с ней
2) необходимость ослабления связанности подсистемы с клиентами


Приспособленец (flyweight) - поддержка множества мелких объектов

Проблема - Проектирование объектов самых низких уровней системы, может обеспечить ее оптимальную гибкость, однако 
сопровождается неприемлемыми затратами памяти и производительности.

Использует разделение для поддержания множества мелких объектов

Примеры использования:
1) Когда используется большое кол-во объектов
2) большую часть состояния объектов можно вынести наружу
3) приложение не зависит от идентичности объекта


Заместитель (proxy) - для замещения другого объекта и доступа к нему

используется для обеспечения контроля доступа к определённому объекту

Примеры использования:
1) когда есть необходимость ссылаться на объект способом отличным от обычного указателя
удалённое замещение - локальный представитель вместо объекта в другом адресном пространстве
виртуальное замещение - создание "тяжёлых" объектов при необходимости
защищённое замещение - контроль доступа к указанному объекту
"умная" ссылка - замена обычного указателя (подсчёт числа ссылок, установка блокировки и т.д.)


Цепочка ответственности (chain of responsibility) - связыывние объектов-получателей в цепочку и передача запроса по ней

Используется для того, чтобы избежать привязки отправителя запроса к его получателю, что даёт возможность обрабатывать 
данный запрос нескольким объектам

Примеры использования:
- ослабление привязанности (объект не должен знать, кто именно обрабатывает его запрос)
- дополнительная гибкость при распределении обязанностей между объектами


Команда (Command) - инкапсулирование запроса от объекта

Используется чтобы задать параметры клиентов для обработки определённых запросов, создание очереди из этих запросов или 
их контроля и поддержки отмены операций

Примеры использования:
1) Параметризация объектов выполняемым действием
2) Определять запрос, ставить его в очередь или выполнять его в разное время


Интерепретатор(Interpreter) - определение представления грамматики объекта

Используется для определения представления грамматики заданного языка и интерпретации его предложений

Примеры использования:
1) Упрощение иерархии классов с помощью интерпретирования


Итератор(Iterator) - получение последовательного доступа ко всем элементам составного объекта

Используется для получения последовательного доступа ко всем элементам составного объекта, скрывая его внутреннее представление

Примеры использования:
1) различные виды обхода составного объекта
2) упрощёнынй доступ к составному объекту


Mediator(посредник) - инкапсуляция способа взаимодействия множества объектов

Используется для определения объекта, который инкапсулирует способ взаимодействия множества объектов и обеспечения 
слабой связи между этими объектами

Примеры использования:
1) Связи между объектами сложны и чётко определены
2) Нельзя повторно использовать объект, так как он обменивается информацией с другими объектами
3) Поведение, распределённное между несколькими классами должно легко настраиватся без создания подклассов

Хранитель (Memento)  - сохранить внетреннее состояние объекта за его пределы

Используется для фиксирования внутреннего состояния объекта за его пределеами не нарушая инкапсуляцию и восстановление 
объекта в случае необходимости

Примеры использования: 
1) необходимо сохранить текущее состояние объекта или его части и восстановление в будущем, но прямое получение состояния 
раскрывает детали реализации и нарушает инкапсуляцию объекта


Наблюдатель(Observer) - определение зависимости "один ком ногим" между объектами

Используется для определения зависимости "один ко многим" между объектами таким образом, что при изменении состояния 
одного объекта все зависящие от него объекты были уведомлены об этом и обновились

Пример использования:
1) Когда у модели имеются два аспекта, один из которых зависит от другого. Инкапсулирование этих аспектов в разные 
классы позволяет использовать их независимо друг от друга 
2) Когда один объект должен обовещать другие и не делать предположений об этих объектах
3) Ослабление связи между объектами

Состояние(State) - управление поведением объекта в зависимости от состояния

Позволяет управлять поведением объекта в зависимости от внутреннего состояния объекта;

Примеры использования:
1) Поведение объекта зависит от его состояния и изменяется со временем выполнения
2) Когда встречается большое кол-во условных операторов, когда выбор ветви зависит от состояния объекта


Стратегия(Strategy) - взаимозаменяемость семейства классов

Используется для определения семейства классов, инкапсулирования каждого из них и организация их взаимозаменяемости

Примеры использования:
1) Есть несколько родственных классов, которые отличаются поведением
2) необходимо иметь несколько вариантов поведения
3) В классе есть данные, о которых не должен знать клиент
4) С помощью условных операторов в классе определено большое кол-во возможных поведений

Шаблонный метод (template method) - определение основы класса и создание возможности подклассам переопределять его части

Используется для определения основы класса и позволяет переопределить некоторые его части не изменяя его структуру в целом

Примеры использования:
1) Однократное использование различных частей класса, оставляя реализацию изменяющегося поведения на усмотрение подклассов
2) Вычленение и локализация общего для вех подклассов поведения в родительском
3) Управление расширениями подклассов


Посетитель(Visitor) - описание действий, которые выполняются с каждым объектом в некоторой структуре

Используется для описания операций, которые выполняются с каждым объектом из некоторой структуры. Позволяет определить 
новую операцию без изменеия классов этиъ объектов

Примеры использования:
1) В структуре пресутствуют объекты многих классов с различными интерфейсами и нам необходимо выполнить над ними оперции, 
которые зависят от конкретных классов
2) Необходимо выполнять не связанные между собой операции над объектами, которые входят в состав структуры и мы не хотим 
добавлять эти операции в классы 
3) Классы, которые утсанавливают структуру объектов редко изменяются, но частодобавляются новые операции над этой структурой


